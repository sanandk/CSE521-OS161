diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..8ab98fc 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -112,6 +112,8 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
 	 * You will probably want to change this.
 	 */
 
+	sys___exit(0);
+
 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
 		code, sig, trapcodenames[code], epc, vaddr);
 	panic("I don't know how to handle this\n");
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..e09500d 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -30,6 +30,7 @@
 #include <types.h>
 #include <kern/errno.h>
 #include <kern/syscall.h>
+#include <copyinout.h>
 #include <lib.h>
 #include <mips/trapframe.h>
 #include <thread.h>
@@ -79,8 +80,9 @@ void
 syscall(struct trapframe *tf)
 {
 	int callno;
-	int32_t retval;
+	int32_t retval,retval2;
 	int err;
+	int whence;
 
 	KASSERT(curthread != NULL);
 	KASSERT(curthread->t_curspl == 0);
@@ -98,18 +100,76 @@ syscall(struct trapframe *tf)
 	 */
 
 	retval = 0;
-
+	retval2=0;
 	switch (callno) {
+
 	    case SYS_reboot:
 		err = sys_reboot(tf->tf_a0);
 		break;
 
+	    case SYS_fork:
+		err = sys___fork(&retval,tf);
+		break;
+
+	    case SYS_execv:
+		err = sys___execv(&retval,(const char*)tf->tf_a0,(char **)tf->tf_a1);
+		break;
+
+	    case SYS__exit:
+		err = 0;
+		sys___exit((int)tf->tf_a0);
+		break;
+
 	    case SYS___time:
 		err = sys___time((userptr_t)tf->tf_a0,
 				 (userptr_t)tf->tf_a1);
 		break;
 
-	    /* Add stuff here */
+	    case SYS_getpid:
+	    err=sys___getpid(&retval);
+	    break;
+
+	    case SYS_waitpid:
+	    err=sys___waitpid(&retval, (pid_t) tf->tf_a0, (int *) tf->tf_a1,(int) tf->tf_a2);
+	    break;
+
+	    case SYS_open:
+			err=sys___open(&retval,(char *)tf->tf_a0,
+								 (mode_t)tf->tf_a1,
+								 (int)tf->tf_a2);
+			break;
+	    case SYS_close:
+			err=sys___close(&retval,(int)tf->tf_a0);
+			break;
+
+	    case SYS_write:
+			err=sys___write(&retval,(int)tf->tf_a0,
+								 (void *)tf->tf_a1,
+								 (size_t)tf->tf_a2);
+			break;
+	    case SYS_read:
+			err=sys___read(&retval,(int)tf->tf_a0,
+								 (void *)tf->tf_a1,
+								 (size_t)tf->tf_a2);
+			break;
+
+	    case SYS_dup2:
+			err=sys___dup2(&retval,(int)tf->tf_a0,
+								 (int)tf->tf_a1);
+			break;
+	    case SYS_chdir:
+			err=sys___chdir(&retval,(char *)tf->tf_a0);
+			break;
+	    case SYS___getcwd:
+			err=sys___getcwd(&retval,(char *)tf->tf_a0,
+								(size_t)tf->tf_a1);
+			break;
+	    case SYS_lseek:
+	    	err=copyin((const_userptr_t)tf->tf_sp+16, &whence, sizeof(int));
+			err=sys___lseek(&retval,&retval2,(int)tf->tf_a0,
+					((off_t)tf->tf_a2) << 32 | tf->tf_a3,whence);
+			tf->tf_v1 = retval2;
+			break;
  
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
@@ -130,6 +190,7 @@ syscall(struct trapframe *tf)
 	else {
 		/* Success. */
 		tf->tf_v0 = retval;
+
 		tf->tf_a3 = 0;      /* signal no error */
 	}
 	
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..2f16a3f 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -330,6 +330,7 @@ file      thread/threadlist.c
 #
 
 file      vm/kmalloc.c
+file      vm/vm.c
 
 optofffile dumbvm   vm/addrspace.c
 
@@ -367,6 +368,8 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file      syscall/process_syscalls.c
+file      syscall/file_syscalls.c
 
 #
 # Startup and initialization
diff --git a/kern/include/addrspace.h b/kern/include/addrspace.h
index 6788e97..f4c432a 100644
--- a/kern/include/addrspace.h
+++ b/kern/include/addrspace.h
@@ -59,6 +59,13 @@ struct addrspace {
         paddr_t as_stackpbase;
 #else
         /* Put stuff here for your VM system */
+        vaddr_t as_vbase1;
+               paddr_t as_pbase1;
+               size_t as_npages1;
+               vaddr_t as_vbase2;
+               paddr_t as_pbase2;
+               size_t as_npages2;
+               paddr_t as_stackpbase;
 #endif
 };
 
diff --git a/kern/include/copyinout.h b/kern/include/copyinout.h
index 055dcff..2af0596 100644
--- a/kern/include/copyinout.h
+++ b/kern/include/copyinout.h
@@ -65,6 +65,11 @@
  */
 
 int copyin(const_userptr_t usersrc, void *dest, size_t len);
+int
+copystr2(char *dest, const char *src, size_t maxlen, size_t stoplen,
+	size_t *gotlen);
+int
+copycheck2(const_userptr_t userptr, size_t len, size_t *stoplen);
 int copyout(const void *src, userptr_t userdest, size_t len);
 int copyinstr(const_userptr_t usersrc, char *dest, size_t len, size_t *got);
 int copyoutstr(const char *src, userptr_t userdest, size_t len, size_t *got);
diff --git a/kern/include/cpu.h b/kern/include/cpu.h
index 2b03349..3f6aea8 100644
--- a/kern/include/cpu.h
+++ b/kern/include/cpu.h
@@ -33,6 +33,7 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
+#include <limits.h>
 #include <machine/vm.h>  /* for TLBSHOOTDOWN_MAX */
 
 
@@ -46,6 +47,13 @@
  * a pointer with a fixed address and a per-cpu mapping in the MMU.
  */
 
+struct process {
+	struct thread *tptr;
+	int exitcode;
+	struct semaphore *esem;
+	pid_t pid,ppid;
+};
+
 struct cpu {
 	/*
 	 * Fixed after allocation.
@@ -54,6 +62,8 @@ struct cpu {
 	unsigned c_number;		/* This cpu's cpu number */
 	unsigned c_hardware_number;	/* Hardware-defined cpu number */
 
+	pid_t c_processcount;	/* for PID allocation */
+
 	/*
 	 * Accessed only by this cpu.
 	 */
@@ -69,6 +79,7 @@ struct cpu {
 	struct threadlist c_runqueue;	/* Run queue for this cpu */
 	struct spinlock c_runqueue_lock;
 
+
 	/*
 	 * Accessed by other cpus.
 	 * Protected by the IPI lock.
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..8072d20 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,6 +74,10 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
+//	volatile int lk_lock;	//lock data
+	struct thread *lk_holder;	//CPU holding this lock
+	struct wchan *lk_wchan;
+	struct spinlock lk_slock;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -95,6 +99,9 @@ void lock_acquire(struct lock *);
 void lock_release(struct lock *);
 bool lock_do_i_hold(struct lock *);
 void lock_destroy(struct lock *);
+int lock_data_get(volatile int *);
+void lock_data_set(volatile int *, int );
+int lock_data_testandset(volatile int *);
 
 
 /*
@@ -113,6 +120,8 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
+	struct wchan *cv_wchan;
+        volatile int cv_count;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -143,6 +152,12 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+        struct cv *turn;
+        volatile int writing, reading;
+        volatile int writers;
+        struct lock *rw_lock;
+        struct semaphore *rw_sem;
+        int current_turn; // 0 for readers,1 for writers
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..7ba3678 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -30,6 +30,10 @@
 #ifndef _SYSCALL_H_
 #define _SYSCALL_H_
 
+#include <limits.h>
+
+	int pcount;
+	struct process *plist[PID_MAX];
 
 struct trapframe; /* from <machine/trapframe.h> */
 
@@ -54,8 +58,32 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 /*
  * Prototypes for IN-KERNEL entry points for system call implementations.
  */
-
+int std_open(int fd, int flags);
 int sys_reboot(int code);
+int sys___exit(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
 
+int sys___getpid(int *ret);
+int
+sys___waitpid(int *ret,pid_t pid, int *status, int options);
+int entrypoint(void *, void *);
+int sys___fork(int *ret,struct trapframe *);
+int
+sys___execv(int *ret,const char *program, char **uargs);
+int
+sys___open(int *, char *, int , mode_t);
+int
+sys___read(int *ret, int fd, void *buf, size_t bufsize);
+int
+sys___write(int *ret, int fd, void *buf, size_t bufsize);
+int
+sys___close(int *ret, int fd);
+int
+sys___dup2(int *ret, int , int );
+int
+sys___chdir(int *ret, char *);
+int
+sys___getcwd(int *ret, char *buf, size_t buflen);
+int
+sys___lseek(int *,int *, int fd, off_t offset, int whence);
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..c69ca4d 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -89,6 +89,7 @@ int threadtest3(int, char **);
 int semtest(int, char **);
 int locktest(int, char **);
 int cvtest(int, char **);
+int rwtest(int, char **);
 int cvtest2(int, char **);
 
 /* filesystem tests */
@@ -105,7 +106,7 @@ int mallocstress(int, char **);
 int nettest(int, char **);
 
 /* Routine for running a user-level program. */
-int runprogram(char *progname);
+int runprogram(char *progname, int, char **);
 
 /* Kernel menu system. */
 void menu(char *argstr);
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..846d7c5 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -36,6 +36,7 @@
  * Note: curthread is defined by <current.h>.
  */
 
+#include <limits.h>
 #include <spinlock.h>
 #include <threadlist.h>
 
@@ -65,8 +66,20 @@ typedef enum {
 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
 } threadstate_t;
 
+
+/* ASST2 - File Handle Structure */
+struct file_handle {
+	char *file_name;
+	mode_t op_flags;
+	off_t file_offset;
+	struct vnode *file_ref;
+	struct lock *file_lock;
+	int file_counter;
+};
+
 /* Thread structure. */
 struct thread {
+
 	/*
 	 * These go up front so they're easy to get to even if the
 	 * debugger is messed up.
@@ -111,9 +124,20 @@ struct thread {
 	/* VFS */
 	struct vnode *t_cwd;		/* current working directory */
 
+	/* ASST2 Additions   */
+	int priority;	/* 1- low, 2-med, 3-high */
+	pid_t process_id;
+	int exit_code;
+	struct semaphore *exit_sem;
+	struct thread *parent;
+	int fd_count;
+	struct file_handle *f_handles[OPEN_MAX];	/* Pointer to file handles */
+
 	/* add more here as needed */
 };
 
+pid_t pid_allocate(void);
+
 /* Call once during system startup to allocate data structures. */
 void thread_bootstrap(void);
 
@@ -140,6 +164,8 @@ int thread_fork(const char *name,
                 void *data1, unsigned long data2, 
                 struct thread **ret);
 
+
+
 /*
  * Cause the current thread to exit.
  * Interrupts need not be disabled.
diff --git a/kern/include/vm.h b/kern/include/vm.h
index e4e73d0..d0eb4cc 100644
--- a/kern/include/vm.h
+++ b/kern/include/vm.h
@@ -43,17 +43,32 @@
 #define VM_FAULT_READ        0    /* A read was attempted */
 #define VM_FAULT_WRITE       1    /* A write was attempted */
 #define VM_FAULT_READONLY    2    /* A write to a readonly page was attempted*/
+enum page_state_t {FREE, DIRTY, CLEAN, FIXED};
+struct coremap_page {
+    /* where is paged mapped to */
+    struct addrspace *aspace;
+    vaddr_t vaddr;
 
+    /* page state */
+    enum page_state_t pstate;
+
+    int npages; //single/multi page allocation
+
+    /* other info for paging algorithm  */
+
+};
 
 /* Initialization function */
 void vm_bootstrap(void);
 
 /* Fault handling function called by trap code */
 int vm_fault(int faulttype, vaddr_t faultaddress);
-
+vaddr_t alloc_page(void);
 /* Allocate/free kernel heap pages (called by kmalloc/kfree) */
 vaddr_t alloc_kpages(int npages);
+
 void free_kpages(vaddr_t addr);
+void free_page(vaddr_t addr);
 
 /* TLB shootdown handling called from interprocessor_interrupt */
 void vm_tlbshootdown_all(void);
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..4ea9d8b 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -1,4 +1,4 @@
-/*
+/* anandaka@buffalo.edu
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
  *	The President and Fellows of Harvard College.
  *
@@ -99,12 +99,13 @@ boot(void)
 	kprintf("OS/161 base system version %s\n", BASE_VERSION);
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
-
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	DEBUG(DB_VM, "Print Header");
+	kprintf("anandaka@buffalo.edu and karthikj@buffalo.edu system version %s (%s #%d)\n",
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
 	/* Early initialization. */
+	DEBUG(DB_VM, "Early Initialization");
 	ram_bootstrap();
 	thread_bootstrap();
 	hardclock_bootstrap();
@@ -112,18 +113,20 @@ boot(void)
 
 	/* Probe and initialize devices. Interrupts should come on. */
 	kprintf("Device probe...\n");
+	DEBUG(DB_VM, "Initialize devices");
 	KASSERT(curthread->t_curspl > 0);
 	mainbus_bootstrap();
 	KASSERT(curthread->t_curspl == 0);
 	/* Now do pseudo-devices. */
+	DEBUG(DB_VM, "Initialize pseudo-devices");
 	pseudoconfig();
 	kprintf("\n");
-
+	kprintf("\nVM_BOOT\n");
 	/* Late phase of initialization. */
 	vm_bootstrap();
 	kprintf_bootstrap();
 	thread_start_cpus();
-
+	DEBUG(DB_VM, "Late Initialization");
 	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
 	vfs_setbootfs("emu0");
 
@@ -144,7 +147,7 @@ shutdown(void)
 {
 
 	kprintf("Shutting down.\n");
-	
+	DEBUG(DB_VM, "Shutting down");
 	vfs_clearbootfs();
 	vfs_clearcurdir();
 	vfs_unmountall();
@@ -166,6 +169,7 @@ shutdown(void)
 int
 sys_reboot(int code)
 {
+	DEBUG(DB_VM, "Rebooting");
 	switch (code) {
 	    case RB_REBOOT:
 	    case RB_HALT:
@@ -203,9 +207,10 @@ sys_reboot(int code)
 void
 kmain(char *arguments)
 {
+	DEBUG(DB_VM, "Booting");
 	boot();
-
+	DEBUG(DB_VM, "Printing Menu");
 	menu(arguments);
-
+	DEBUG(DB_VM, "Finish main");
 	/* Should not get here */
 }
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..a16db85 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -100,7 +100,7 @@ cmd_progthread(void *ptr, unsigned long nargs)
 
 	strcpy(progname, args[0]);
 
-	result = runprogram(progname);
+	result = runprogram(progname,nargs,args);
 	if (result) {
 		kprintf("Running program %s failed: %s\n", args[0],
 			strerror(result));
@@ -126,22 +126,27 @@ static
 int
 common_prog(int nargs, char **args)
 {
-	int result;
+	int result,status,ret;
 
 #if OPT_SYNCHPROBS
 	kprintf("Warning: this probably won't work with a "
 		"synchronization-problems kernel.\n");
 #endif
-
+	struct thread *pthread;
 	result = thread_fork(args[0] /* thread name */,
 			cmd_progthread /* thread function */,
 			args /* thread arg */, nargs /* thread arg */,
-			NULL);
+			&pthread);
 	if (result) {
 		kprintf("thread_fork failed: %s\n", strerror(result));
 		return result;
 	}
-
+	result=sys___waitpid(&ret,pthread->process_id,&status, 909);
+	if (result) {
+		kprintf("waitpid failed: %s\n", strerror(result));
+		return 0;
+	}
+	//kprintf("\nwaitpid returned %d!",result);
 	return 0;
 }
 
@@ -447,6 +452,7 @@ static const char *testmenu[] = {
 	"[net] Network test                  ",
 #endif
 	"[sy1] Semaphore test                ",
+	"[rw] RW test                    ",
 	"[sy2] Lock test             (1)     ",
 	"[sy3] CV test               (1)     ",
 	"[sy5] CV test 2             (1)     ",
@@ -542,7 +548,7 @@ static struct {
 	{ "tt2",	threadtest2 },
 	{ "tt3",	threadtest3 },
 	{ "sy1",	semtest },
-
+	{ "rw",	rwtest },
 	/* synchronization assignment tests */
 	{ "sy2",	locktest },
 	{ "sy3",	cvtest },
diff --git a/kern/synchprobs/drivers.c b/kern/synchprobs/drivers.c
index 02e336f..548d2fa 100644
--- a/kern/synchprobs/drivers.c
+++ b/kern/synchprobs/drivers.c
@@ -60,7 +60,7 @@ inline void matchmaker_end(void) {
  * order or timing of threads launched by our testing suite.
  */
 
-#define NMATING 10
+#define NMATING 1
 
 struct semaphore * whalematingMenuSemaphore;
 
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..fa79c95 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -35,6 +35,7 @@
 #include <thread.h>
 #include <test.h>
 #include <synch.h>
+#include <current.h>
 
 /*
  * 08 Feb 2012 : GWA : Driver code is in kern/synchprobs/driver.c. We will
@@ -46,8 +47,44 @@
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+struct semaphore *malesem;
+struct semaphore *femalesem;
+struct semaphore *matchmakersem,*testsem, *testsem2, *testsem3;
+struct lock *jlock;
+struct semaphore *mutex;
+
+int j[4], head[4];
+
+
+int male_cnt,female_cnt,match_cnt;
 
 void whalemating_init() {
+	malesem = sem_create("Whalemating Male Semaphore",0);
+	femalesem = sem_create("Whalemating Female Semaphore",0);
+	matchmakersem = sem_create("Whalemating MatchMaker Semaphore",0);
+
+	if (testsem==NULL) {
+			testsem = sem_create("testsem", 0);
+			if (testsem == NULL) {
+				panic("synchtest: sem_create failed\n");
+			}
+		}
+	if (testsem2==NULL) {
+			testsem2= sem_create("testsem2", 0);
+				if (testsem2== NULL) {
+					panic("synchtest: sem_create failed\n");
+				}
+			}
+	if (testsem3==NULL) {
+			testsem3= sem_create("testsem3", 0);
+				if (testsem3== NULL) {
+					panic("synchtest: sem_create failed\n");
+				}
+			}
+	male_cnt=0;
+	female_cnt=0;
+	match_cnt=0;
+
   return;
 }
 
@@ -63,10 +100,27 @@ male(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
-  male_start();
-	// Implement this function 
-  male_end();
+	male_start();
+	V(malesem);
+	P(testsem);
+
+	//P(matchmakersem);
+
+	/*V(testsem);
+	V(testsem);
+	V(testsem);
+	P(testsem);
+	*/
+	//male_cnt++;
+	male_end();
+	//V(testsem2);
+
+
+	//V(matchmakersem);
+	//V(femalesem);
+
+
+
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
@@ -79,11 +133,30 @@ female(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
   female_start();
-	// Implement this function 
-  female_end();
-  
+
+    V(femalesem);
+	//P(malesem);
+		P(testsem2);
+
+/*		V(testsem);
+		V(testsem);
+		V(testsem);
+		P(testsem);
+
+	V(testsem);
+		V(testsem2);
+		V(testsem2);
+		V(testsem2);
+		P(testsem2);
+*/
+	female_end();
+	/*V(testsem2);
+*/
+	//V(matchmakersem);
+	//V(malesem);
+
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
@@ -95,11 +168,31 @@ matchmaker(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
-  matchmaker_start();
-	// Implement this function 
-  matchmaker_end();
-  
+    matchmaker_start();
+
+//	V(matchmakersem);
+	P(malesem);
+	P(femalesem);
+
+
+	V(testsem);
+	V(testsem2);
+	/*P(testsem);
+
+
+	V(testsem);
+	V(testsem2);
+	V(testsem2);
+	V(testsem2);
+	P(testsem2);
+*/
+	matchmaker_end();
+	/*V(testsem2);
+
+	V(femalesem);
+	V(malesem);
+*/
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
@@ -136,8 +229,65 @@ matchmaker(void *p, unsigned long which)
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+#define DIRECTIONS 4
+struct semaphore *quadSem[DIRECTIONS];  //Array Size indicates the number of directions
+/*
+struct semaphore *quadSem1;
+struct semaphore *quadSem2;
+struct semaphore *quadSem3;
+*/
 
 void stoplight_init() {
+
+  for(int i=0; i<DIRECTIONS;i++)
+  {
+    if(quadSem[i]==NULL){
+      quadSem[i] = sem_create("Quadrant Semaphore",1);
+      if (quadSem[i] == NULL) {
+        panic("synchtest: sem_create failed at quadSem\n");
+      }
+    }
+  }
+
+  if(mutex==NULL){
+	  mutex = sem_create("mutex Semaphore",1);
+        if (mutex == NULL) {
+          panic("synchtest: sem_create failed at quadSem\n");
+        }
+      }
+  j[0]=0;
+  j[1]=0;
+  j[2]=0;
+  j[3]=0;
+  head[0]=1;
+  head[1]=1;
+  head[2]=1;
+  head[3]=1;
+
+  jlock=lock_create("j1lock");
+  /*jl[1]=lock_create("j2lock");
+  jl[2]=lock_create("j3lock");
+  jl[3]=lock_create("j4lock");
+*/
+/*  if(quadSem1==NULL){
+    quadSem1 = sem_create("Quadrant 1 Semaphore",0);
+    if (quadSem1 == NULL) {
+      panic("synchtest: sem_create failed at quadSem1\n");
+    }
+  }
+  if(quadSem2==NULL){
+    quadSem2 = sem_create("Quadrant 2 Semaphore",0);
+    if (quadSem2 == NULL) {
+      panic("synchtest: sem_create failed at quadSem2\n");
+    }
+  }
+  if(quadSem3==NULL){
+    quadSem3 = sem_create("Quadrant 3 Semaphore",0);
+    if (quadSem3 == NULL) {
+      panic("synchtest: sem_create failed at quadSem3\n");
+    }
+  }
+*/
   return;
 }
 
@@ -145,6 +295,23 @@ void stoplight_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
+  for(int i=0; i<DIRECTIONS;i++)
+  {
+    if(quadSem[i]!=NULL){
+      sem_destroy(quadSem[i]);
+    }
+  }
+/*
+  if(quadSem1!=NULL){
+    sem_destroy(*quadSem1);
+  }
+  if(quadSem2!=NULL){
+    sem_destroy(*quadSem2);
+  }
+  if(quadSem3!=NULL){
+    sem_destroy(*quadSem3);
+  }
+*/
   return;
 }
 
@@ -153,7 +320,59 @@ gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
+//kprintf("\nGo Straight: %s, %ld\n",curthread->t_name,direction);
+/*
+while(1)
+{
+lock_acquire(jlock);
+if(quadSem[direction]->sem_count==1 && quadSem[(direction+3)%4]->sem_count==1)
+{
+	P(quadSem[direction]);
+	P(quadSem[(direction+3)%4]);
+	break;
+}
+lock_release(jlock);
+}*/
+//int j_id= ++j[direction];
+//while(j_id!=head[direction]);
+
+while(1)
+{
+	P(mutex);
+  P(quadSem[direction]);
+  //ex_flag++;
+  //if(ex_flag==2)
+	  //break;
+if(quadSem[(direction+3)%4]->sem_count!=0)
+{
+	P(quadSem[(direction+3)%4]);
+
+	V(mutex);
+	break;
+}
+else
+{
+	V(quadSem[direction]);
+	V(mutex);
+}
+
+}
+
+  inQuadrant(direction);
   
+
+  //Entering the second quadrant
+
+  inQuadrant((direction+3)%4);
+
+
+  //exiting
+  leaveIntersection();
+  //head[direction]++;
+//  removeHead(j[direction],jl[direction]);
+  V(quadSem[direction]);
+  V(quadSem[(direction+3)%4]);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -164,8 +383,72 @@ void
 turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+//	int j_id= ++j[direction];
+//	while(j_id!=head[direction]);
+//kprintf("\nTurning left: %s, %ld\n",curthread->t_name,direction);
+/*while(1)
+{
+lock_acquire(jlock);
+if(quadSem[direction]->sem_count==1 && quadSem[(direction+3)%4]->sem_count==1 && quadSem[(direction+2)%4]->sem_count==1)
+{
+	P(quadSem[direction]);
+	P(quadSem[(direction+3)%4]);
+	P(quadSem[(direction+2)%4]);
+	break;
+}
+lock_release(jlock);
+}*/
+//insertEnd(j[direction],jl[direction],curthread->t_name);
+//int ex_flag=0;
+//while(!am_i_first(j[direction],curthread->t_name));
+
+while(1)
+{
+	P(mutex);
+	//Entering the first quadrant
+  P(quadSem[direction]);
+
+//kprintf("\nTurning left: %s acquired %ld\n",curthread->t_name,direction);
+
+  //Entering the second quadrant;
+if(quadSem[(direction+3)%4]->sem_count>0)
+{
+  P(quadSem[(direction+3)%4]);
+if(quadSem[(direction+2)%4]->sem_count>0)
+{
+  P(quadSem[(direction+2)%4]);
+  	  V(mutex);
+	break;
+}
+else
+{
+	V(quadSem[(direction+3)%4]);
+	V(quadSem[direction]);
+}
+}
+else
+	V(quadSem[direction]);
+V(mutex);
+//kprintf("\nTurning left: %s acquired %ld\n",curthread->t_name,(direction+3)%4);
+
+}
+//kprintf("\nTurning left: %s acquired %ld\n",curthread->t_name,(direction+2)%4);
+
+  inQuadrant(direction);
   
+  inQuadrant((direction+3)%4);
+
+  inQuadrant((direction+2)%4);
+
+  //exiting
+  leaveIntersection();
+//  head[direction]++;
+//  removeHead(j[direction],jl[direction]);
+  V(quadSem[direction]);
+  V(quadSem[(direction+3)%4]);
+  V(quadSem[(direction+2)%4]);
+
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -176,7 +459,26 @@ void
 turnright(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+
+	//int j_id= ++j[direction];
+	//while(j_id!=head[direction]);
+//  while(!am_i_first(j[direction],curthread->t_name));
+//kprintf("\nTurning right: %s, %ld\n",curthread->t_name,direction);
+//insertEnd(j[direction],jl[direction],curthread->t_name);
+  //Entering the first and final quadrant
+
+	P(mutex);
+	P(quadSem[direction]);
+	V(mutex);
+
+//kprintf("\nTurning right: %s acquired %ld\n",curthread->t_name,direction);
+  inQuadrant(direction);
+
+  //exiting
+  leaveIntersection();
+  //head[direction]++;
+//  removeHead(j[direction],jl[direction]);
+  V(quadSem[direction]);
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
new file mode 100644
index 0000000..109d32c
--- /dev/null
+++ b/kern/syscall/file_syscalls.c
@@ -0,0 +1,499 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+
+#include <types.h>
+#include <thread.h>
+#include <kern/errno.h>
+#include <synch.h>
+#include <uio.h>
+#include <syscall.h>
+#include <lib.h>
+#include <vnode.h>
+#include <vfs.h>
+#include <kern/fcntl.h>
+#include <kern/seek.h>
+#include <kern/stat.h>
+#include <current.h>
+#include <kern/wait.h>
+#include <copyinout.h>
+
+/*
+ * sys_getpid system call: get current process id
+ */
+
+
+int std_open(int fd, int flags)
+{
+	struct vnode *v;
+	char *c;
+	c=kstrdup("con:");
+		int i=fd,result;
+
+		/* Open the file. */
+		result = vfs_open(c, flags, 0, &v);
+		if (result) {
+			// error
+			kfree(v);
+			return EINVAL;
+		}
+
+		curthread->f_handles[i]=kmalloc(sizeof(*curthread->f_handles[i]));
+		curthread->f_handles[i]->file_counter=1;
+		curthread->f_handles[i]->file_name=kstrdup(c);
+		curthread->f_handles[i]->file_offset=0;
+		curthread->f_handles[i]->file_ref=v;
+		curthread->f_handles[i]->op_flags=flags;
+		curthread->f_handles[i]->file_lock=lock_create(c);
+		return 0;
+}
+
+
+/*
+ * sys_open system call: open file
+ */
+int
+sys___open(int *ret, char *filename, int flags, mode_t mode)
+{
+	struct vnode *v;
+	int i,result;
+	char *fname;
+	size_t len;
+
+	/*if(filename==NULL)
+	{
+			*ret=-1;
+			return EFAULT;
+	}*/
+	if(flags>66)
+	{
+		*ret=-1;
+		return EINVAL;
+	}
+	//fname=filename;
+	/*result = copycheck2((const_userptr_t) filename, PATH_MAX, &len);
+	if (result) {
+		kprintf("|copycheck2 failed|");
+		*ret=-1;
+		return result;
+	}*/
+	fname=kmalloc(sizeof(char)*PATH_MAX);
+	result= copyinstr((const_userptr_t) filename, fname, PATH_MAX, &len);
+
+		if (result)
+		{
+			*ret=-1;
+			return result;
+		}
+
+	/* Open the file. */
+	result = vfs_open(fname, flags, mode, &v);
+	if (result) {
+		// error
+		*ret=-1;
+		return EINVAL;
+	}
+
+
+	/* Allocate FD 	 */
+
+	for(i=3;i<curthread->fd_count+3;i++)
+	{
+		if(curthread->f_handles[i]==NULL)
+			break;
+	}
+	if(i==OPEN_MAX)
+	{
+		*ret=-1;
+		return EMFILE;
+	}
+
+	curthread->f_handles[i]=kmalloc(sizeof(*curthread->f_handles[i]));
+	if(i>curthread->fd_count)
+		curthread->fd_count++;
+	curthread->f_handles[i]->file_counter=1;
+	curthread->f_handles[i]->file_name=kstrdup(fname);
+	curthread->f_handles[i]->file_offset=0;
+	curthread->f_handles[i]->op_flags=flags;
+	curthread->f_handles[i]->file_ref=v;
+	curthread->f_handles[i]->file_lock=lock_create(fname);
+	*ret=i;
+
+	return 0;
+}
+
+int
+sys___read(int *ret, int fd, void *buf, size_t bufsize)
+{
+
+	if(fd<0 || fd>=OPEN_MAX)
+	{
+		*ret=-1;
+		return EBADF;
+	}
+	void *kbuf=kmalloc(sizeof(*buf)*bufsize);
+	int result;
+	if(kbuf==NULL)
+	{
+		*ret=-1;
+		return EFAULT;
+	}
+	size_t len;
+	result = copycheck2((const_userptr_t) buf, bufsize, &len);
+		if (result) {
+			return result;
+		}
+
+	if(fd>curthread->fd_count+2 || curthread->f_handles[fd]==NULL)
+	{
+		*ret=-1;
+		return EBADF;
+	}
+	struct file_handle *file=curthread->f_handles[fd];
+	struct vnode *v=file->file_ref;
+	struct iovec iov;
+	struct uio u;
+
+	if(file==NULL || file->op_flags==O_WRONLY)
+	{
+		*ret=-1;
+		return EBADF;
+	}
+
+
+	lock_acquire(file->file_lock);
+
+	iov.iov_ubase = (userptr_t)buf;
+	iov.iov_len = bufsize;		 // length of the memory space
+	u.uio_iov = &iov;
+	u.uio_iovcnt = 1;
+	u.uio_resid = bufsize;          // amount to read from the file
+	u.uio_offset = file->file_offset;
+	u.uio_segflg = UIO_USERSPACE;
+	u.uio_rw = UIO_READ;
+	u.uio_space = curthread->t_addrspace;
+
+	result = VOP_READ(v, &u);
+	if (result) {
+		lock_release(file->file_lock);
+		*ret=-1;
+		return result;
+	}
+
+	file->file_offset=u.uio_offset;
+	*ret=bufsize-u.uio_resid;
+	lock_release(file->file_lock);
+
+	return 0;
+}
+
+int
+sys___write(int *ret, int fd, void *buf, size_t bufsize)
+{
+	if(fd<0 || fd>=OPEN_MAX)
+	{
+		*ret=-1;
+		return EBADF;
+	}
+	if( fd>curthread->fd_count+2 || curthread->f_handles[fd]==NULL)
+	{
+			*ret=-1;
+			return EBADF;
+	}
+
+	void *kbuf=kmalloc(sizeof(*buf)*bufsize);
+	if(kbuf==NULL)
+	{
+		*ret=-1;
+		return EINVAL;
+	}
+	int result;
+	size_t len;
+	result = copycheck2((const_userptr_t) buf, bufsize, &len);
+	if (result) {
+		return result;
+	}
+
+
+	struct file_handle *file=curthread->f_handles[fd];
+	struct vnode *v=file->file_ref;
+	struct iovec iov;
+	struct uio u;
+
+	if(file==NULL || file->op_flags==O_RDONLY)
+	{
+		*ret=-1;
+		return EBADF;
+	}
+
+	lock_acquire(file->file_lock);
+
+	iov.iov_ubase = (userptr_t)buf;
+	iov.iov_len = bufsize;		 // length of the memory space
+	u.uio_iov = &iov;
+	u.uio_iovcnt = 1;
+	u.uio_resid = bufsize;          // amount to read from the file
+	u.uio_offset = file->file_offset;
+	u.uio_segflg = UIO_USERSPACE;
+	u.uio_rw = UIO_WRITE;
+	u.uio_space = curthread->t_addrspace;
+
+	result = VOP_WRITE(v, &u);
+	if (result) {
+		lock_release(file->file_lock);
+		*ret=-1;
+		return result;
+	}
+
+	file->file_offset=u.uio_offset;
+	*ret=bufsize-u.uio_resid;
+	lock_release(file->file_lock);
+
+	return 0;
+}
+
+
+/*
+ * sys_close system call: close file
+ */
+int
+sys___close(int *ret, int fd)
+{
+	if(fd<0 || fd>OPEN_MAX || fd>curthread->fd_count+2)
+	{
+		*ret=-1;
+		return EBADF;
+	}
+
+	struct vnode *v=curthread->f_handles[fd]->file_ref;
+
+	if(curthread->f_handles[fd]->file_counter==1)
+	{
+		//vfs_close(v);
+		VOP_CLOSE(v);
+		lock_destroy(curthread->f_handles[fd]->file_lock);
+		kfree(curthread->f_handles[fd]);
+		curthread->f_handles[fd]=NULL;
+		curthread->fd_count--;
+	}
+	else
+		curthread->f_handles[fd]->file_counter--;
+
+
+
+		// error
+		*ret=0;
+		return 0;
+
+}
+
+int
+sys___dup2(int *ret, int oldfd, int newfd)
+{
+	//kprintf("old fd is %d,%d,%d",oldfd,newfd,curthread->fd_count);
+	if(oldfd<0 || oldfd>=OPEN_MAX || newfd<0 || newfd>=OPEN_MAX)
+	{
+		*ret=-1;
+		return EBADF;
+	}
+	if(oldfd==newfd)
+	{
+		*ret=oldfd;
+		return 0;
+	}
+	if(oldfd>curthread->fd_count+2)
+	{
+		*ret=-1;
+		return EBADF;
+	}
+
+	if(newfd<=curthread->fd_count+2 && curthread->f_handles[newfd]!=NULL)
+		sys___close(ret,newfd);
+
+	lock_acquire(curthread->f_handles[oldfd]->file_lock);
+	if(curthread->fd_count+2<newfd)
+		curthread->fd_count=newfd-2;
+	curthread->f_handles[newfd]=kmalloc(sizeof(*curthread->f_handles[newfd]));
+	curthread->f_handles[newfd]->file_counter=curthread->f_handles[oldfd]->file_counter;
+	curthread->f_handles[newfd]->file_name=kstrdup(curthread->f_handles[oldfd]->file_name);
+	curthread->f_handles[newfd]->file_offset=curthread->f_handles[oldfd]->file_offset;
+	curthread->f_handles[newfd]->file_ref=curthread->f_handles[oldfd]->file_ref;
+	curthread->f_handles[newfd]->op_flags=curthread->f_handles[oldfd]->op_flags;
+	curthread->f_handles[newfd]->file_lock=lock_create("dup2");
+	lock_release(curthread->f_handles[oldfd]->file_lock);
+	*ret=newfd;
+	return 0;
+
+}
+
+int
+sys___chdir(int *ret, char *dirname)
+{
+	char *dname;
+
+	if(dirname==NULL)
+	{
+		*ret=-1;
+		return EFAULT;
+	}
+	size_t len;
+	int result= copyinstr((const_userptr_t) dirname, dname, PATH_MAX, &len);
+
+	if (result)
+	{
+		*ret=-1;
+		return result;
+	}
+
+	if(dname==NULL)
+	{
+		*ret=-1;
+		return EFAULT;
+	}
+	result = vfs_chdir(dirname);
+		if (result) {
+			*ret=result;
+			return -1;
+		}
+		*ret=0;
+		return 0;
+}
+int
+sys___getcwd(int *ret, char *buf, size_t buflen)
+{
+	struct iovec iov;
+	struct uio ku;
+
+	if(buf==NULL)
+	{
+			*ret=-1;
+			return EFAULT;
+	}
+	void *kbuf=kmalloc(sizeof(*buf)*buflen);
+	if(kbuf==NULL)
+	{
+		*ret=-1;
+		return EFAULT;
+	}
+	size_t len;
+	int result = copycheck2((const_userptr_t) buf, buflen, &len);
+	if (result) {
+		return result;
+	}
+
+		result= copyinstr((const_userptr_t) buf, kbuf, buflen, &len);
+		if (result)
+		{
+			*ret=-1;
+			return result;
+		}
+
+
+	uio_kinit(&iov, &ku, buf, buflen, 0, UIO_READ);
+	result = vfs_getcwd(&ku);
+	if (result) {
+		*ret=-1;
+		return result;
+	}
+
+	/* null terminate */
+	buf[sizeof(buf)-1-ku.uio_resid] = 0;
+	*ret=strlen(buf);
+	return 0;
+}
+int
+sys___lseek(int *ret,int *ret2, int fd, off_t offset, int whence)
+{
+	off_t new_pos,fsize;
+	if(fd<0 || fd>OPEN_MAX || curthread->f_handles[fd]==NULL)
+	{
+		*ret=-1;
+		return EBADF;
+	}
+	if(fd>curthread->fd_count+2)
+	{
+		//kprintf("fd is %d,%d",fd,curthread->fd_count);
+		*ret=-1;
+		return EBADF;
+	}
+/*	if(fd>=0 && fd<3)
+	{
+		*ret=-1;
+		return ESPIPE;
+	}
+*/
+	struct stat fs;
+
+	lock_acquire(curthread->f_handles[fd]->file_lock);
+	int result=VOP_STAT(curthread->f_handles[fd]->file_ref,&fs);
+	if(result)
+	{
+		*ret=-1;
+		lock_release(curthread->f_handles[fd]->file_lock);
+		return result;
+	}
+	fsize=fs.st_size;
+	switch(whence)
+	{
+	case SEEK_SET:
+		new_pos=offset;
+		break;
+	case SEEK_END:
+		new_pos=fsize+offset;
+		break;
+	case SEEK_CUR:
+		new_pos=curthread->f_handles[fd]->file_offset+offset;
+		break;
+	default:	*ret=-1;
+		lock_release(curthread->f_handles[fd]->file_lock);
+		return EINVAL;
+	}
+	if(new_pos<0)
+	{
+		*ret=-1;
+		lock_release(curthread->f_handles[fd]->file_lock);
+		return EINVAL;
+	}
+	result=VOP_TRYSEEK(curthread->f_handles[fd]->file_ref,new_pos);
+	if(result)
+	{
+		*ret=-1;
+		lock_release(curthread->f_handles[fd]->file_lock);
+		return result;
+	}
+	curthread->f_handles[fd]->file_offset=new_pos;
+
+	lock_release(curthread->f_handles[fd]->file_lock);
+
+	*ret=(new_pos & 0xFFFFFFFF00000000) >> 32;
+	*ret2=new_pos & 0xFFFFFFFF;
+
+	return 0;
+}
diff --git a/kern/syscall/process_syscalls.c b/kern/syscall/process_syscalls.c
new file mode 100644
index 0000000..39cd213
--- /dev/null
+++ b/kern/syscall/process_syscalls.c
@@ -0,0 +1,345 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+
+#include <types.h>
+
+#include <kern/errno.h>
+#include <synch.h>
+#include <uio.h>
+#include <syscall.h>
+#include <addrspace.h>
+#include <mips/trapframe.h>
+#include <lib.h>
+#include <vnode.h>
+#include <vfs.h>
+#include <kern/fcntl.h>
+#include <thread.h>
+#include <threadlist.h>
+#include <current.h>
+#include <kern/wait.h>
+#include <copyinout.h>
+#include <cpu.h>
+
+
+/*
+ * sys_getpid system call: get current process id
+ */
+int
+sys___getpid(int *ret)
+{
+
+	*ret=curthread->process_id;
+	return 0;
+}
+
+/*
+ * sys_waitpid system call: get current process id
+ */
+int
+sys___waitpid(int *ret,pid_t pid, int *status, int options)
+{
+	*ret=-1;
+	int res,i;
+	pid_t myparent=-1, hisparent=-2;
+
+	for(i=0;i<pcount;i++)
+	{
+		if(myparent!=-1 && hisparent!=-2)
+			break;
+		if(plist[i]->pid==curthread->process_id)
+			myparent=plist[i]->ppid;
+		else if(plist[i]->pid==pid)
+			hisparent=plist[i]->ppid;
+	}
+
+	if(pid<PID_MIN || pid>PID_MAX)
+		return ESRCH;
+	if(status==NULL)
+		return EFAULT;
+	size_t stoplen;
+	if(options!=909)
+	{
+		res=copycheck2((const_userptr_t) status, sizeof(int), &stoplen);
+		if(res)
+			return EFAULT;
+
+		if(options!=0)
+			return EINVAL;
+
+		res=copyout((const void *)&curthread->exit_code,(userptr_t)status,sizeof(int));
+		if(res)
+			return EFAULT;
+		if(pid==curthread->process_id)
+					return ECHILD;
+		//if(myparent==hisparent)
+			//		return ECHILD;
+		if(options!=909 && hisparent!=curthread->process_id)
+				return ECHILD;
+
+	}
+
+	int excode=0;
+	struct thread *wthread=NULL;
+	for(i=0;i<pcount;i++)
+		if(plist[i]->pid==pid)
+		{
+			wthread=plist[i]->tptr;
+			break;
+		}
+	if(i==pcount)
+		return ESRCH;
+
+
+	if(plist[i]->exitcode == -999)
+		P(plist[i]->esem);
+
+	excode=plist[i]->exitcode;
+
+	if(wthread==NULL && i>=pcount)
+		return ESRCH;
+
+	if(options!=909)
+	{
+		res=copyout((const void *)&excode,(userptr_t)status,sizeof(int));
+		if(res)
+			return EFAULT;
+	}
+	*ret=pid;
+	return 0;
+}
+
+
+int entrypoint(void *child_tf, void* addr)
+{
+	struct trapframe *tf=(struct trapframe *)child_tf;
+	tf->tf_a3=0;	//fork success
+	tf->tf_v0=0;	//fork success
+	tf->tf_epc+=4;
+	curthread->t_addrspace=(struct addrspace *)addr;
+	as_activate(addr);
+	struct trapframe utf=*tf;
+	mips_usermode(&utf);
+	return 0;
+}
+
+/*
+ * sys_fork system call: create a child process
+ */
+int
+sys___fork(int *ret,struct trapframe * tf)
+{
+	*ret=-1;
+	struct addrspace *child_addrspace;
+
+	if(pcount==PID_MAX)
+		return ENPROC;
+
+	struct thread* child_thread;
+
+	int result=as_copy(curthread->t_addrspace,&child_addrspace);
+	if(result)
+	{
+
+		return ENOMEM;
+	}
+
+	struct trapframe *child_tf=kmalloc(sizeof(struct trapframe));
+		if (child_tf==NULL){
+			kprintf("|trapframe malloc failed}");
+			return ENOMEM;
+		}
+		*child_tf=*tf;
+
+	//if (child_addrspace==NULL)
+		//return ENOMEM;
+
+	result = thread_fork("sys_fork", (void *) entrypoint, child_tf, (unsigned long int)child_addrspace, &child_thread);
+	if(result)
+		return result;
+
+	*ret=child_thread->process_id;
+	return 0;
+}
+
+/*
+ * sys_execv system call: run the program
+ */
+int
+sys___execv(int *ret,const char *program, char **uargs)
+{
+
+	struct vnode *v;
+	vaddr_t entrypoint, stackptr;
+	int result,argc;
+	char *pname, **argv;
+	size_t len;
+
+	*ret=-1;
+
+	if(program==NULL || uargs == NULL)
+		return EFAULT;
+
+	pname=kmalloc(sizeof(char)*PATH_MAX);
+
+	result= copyinstr((const_userptr_t) program, pname, PATH_MAX, &len);
+
+	if (result)
+		return result;
+
+	if(len < 2 || len >PATH_MAX)
+		return EINVAL;
+
+	argv=kmalloc(sizeof(char**));
+	result= copyin((const_userptr_t) uargs, argv, sizeof(argv));
+
+	if (result)
+		return result;
+
+	int i=0;
+
+	while(uargs[i]!=NULL){
+			argv[i] = kmalloc(sizeof(uargs[i]));
+			result = copyinstr((const_userptr_t) uargs[i],argv[i], PATH_MAX, &len);
+			if(len>ARG_MAX)
+				return E2BIG;
+			if (result)
+				return result;
+			i++;
+	}
+
+	argc=i;
+
+	/* Open the file. */
+	result = vfs_open(pname, O_RDONLY, 0, &v);
+	if (result) {
+		return result;
+	}
+
+	/* Create a new address space. */
+	curthread->t_addrspace = as_create();
+	if (curthread->t_addrspace==NULL) {
+		vfs_close(v);
+		return ENOMEM;
+	}
+
+	/* Activate it. */
+	as_activate(curthread->t_addrspace);
+
+	/* Load the executable. */
+	result = load_elf(v, &entrypoint);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		vfs_close(v);
+		return result;
+	}
+
+	/* Done with the file now. */
+	vfs_close(v);
+
+	/* Define the user stack in the address space */
+	result = as_define_stack(curthread->t_addrspace, &stackptr);
+	if (result) {
+
+		/* thread_exit destroys curthread->t_addrspace */
+		return result;
+	}
+
+	int olen;
+	i=0;
+	while(i<argc)
+	{
+		//kprintf("%s\n",argv[i++]);
+		len=strlen(argv[i])+1;
+		olen=len;
+		if(len%4!=0)
+			len=len+4-(len%4);
+
+		char *str=kmalloc(sizeof(len));
+		str=kstrdup(argv[i]);	//dont need actually
+		for(int j=0;j<(int)len;j++)
+		{
+			if(j>=olen)
+				str[j]='\0';
+			else
+				str[j]=argv[i][j];
+		}
+
+		stackptr-=len;
+
+		int res=copyout((const void *)str,(userptr_t)stackptr,len);
+
+		if(res)
+			return EFAULT;
+
+		argv[i]=(char *)stackptr;
+
+		i++;
+	}
+
+	//if(argv[i]==NULL){
+		stackptr-=4*sizeof(char);
+	//}
+
+	for(i=argc-1;i>=0;i--)
+	{
+		stackptr-=sizeof(char*);
+		int res=copyout((const void *)(argv+i),(userptr_t)stackptr,sizeof(char*));
+		if(res)
+			return EFAULT;
+	}
+
+	/* Warp to user mode. */
+	enter_new_process(argc, (userptr_t)stackptr,
+			  stackptr, entrypoint);
+
+
+	return 0;
+}
+
+/*
+ * sys_exit system call: exit process
+ */
+int
+sys___exit(int code)
+{
+	int i;
+	curthread->exit_code=_MKWAIT_EXIT(code);
+	for(i=0;i<pcount;i++)
+		if(plist[i]->pid==curthread->process_id)
+		{
+				plist[i]->exitcode=curthread->exit_code;
+				break;
+		}
+
+	V(plist[i]->esem);
+	thread_exit();
+	return 0;
+}
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..192dd90 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -44,6 +44,7 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
+#include <copyinout.h>
 
 /*
  * Load program "progname" and start running it in usermode.
@@ -52,12 +53,19 @@
  * Calls vfs_open on progname and thus may destroy it.
  */
 int
-runprogram(char *progname)
+runprogram(char *progname, int argc, char **uargv)
 {
 	struct vnode *v;
 	vaddr_t entrypoint, stackptr;
 	int result;
 
+	if(curthread->f_handles[0]==NULL)
+		{
+		result=std_open(0,O_RDONLY);
+		result=std_open(1,O_WRONLY);
+		result=std_open(2,O_WRONLY);
+		}
+
 	/* Open the file. */
 	result = vfs_open(progname, O_RDONLY, 0, &v);
 	if (result) {
@@ -95,9 +103,57 @@ runprogram(char *progname)
 		return result;
 	}
 
-	/* Warp to user mode. */
-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
-			  stackptr, entrypoint);
+	char **argv=uargv;
+	size_t len;
+	int olen;
+	int	i=0;
+		while(i<argc)
+		{
+			//kprintf("%s\n",argv[i++]);
+			len=strlen(argv[i])+1;
+			olen=len;
+			if(len%4!=0)
+				len=len+4-(len%4);
+
+			char *str=kmalloc(sizeof(len));
+			str=kstrdup(argv[i]);	//dont need actually
+			for(int j=0;j<(int)len;j++)
+			{
+				if(j>=olen)
+					str[j]='\0';
+				else
+					str[j]=argv[i][j];
+			}
+
+			stackptr-=len;
+
+			int res=copyout((const void *)str,(userptr_t)stackptr,len);
+
+			if(res)
+				return EFAULT;
+
+			argv[i]=(char *)stackptr;
+
+			i++;
+		}
+		stackptr-=4*sizeof(char);
+		//if(argv[i]==NULL){
+			//stackptr-=4*sizeof(char);
+		//}
+
+		for(i=argc-1;i>=0;i--)
+		{
+			stackptr-=sizeof(char*);
+			int res=copyout((const void *)(argv+i),(userptr_t)stackptr,sizeof(char*));
+			if(res)
+				return EFAULT;
+		}
+
+		/* Warp to user mode. */
+		enter_new_process(argc, (userptr_t)stackptr,
+				  stackptr, entrypoint);
+
+
 	
 	/* enter_new_process does not return. */
 	panic("enter_new_process returned\n");
diff --git a/kern/test/synchtest.c b/kern/test/synchtest.c
index d072469..e08bd8d 100644
--- a/kern/test/synchtest.c
+++ b/kern/test/synchtest.c
@@ -41,6 +41,7 @@
 #define NSEMLOOPS     63
 #define NLOCKLOOPS    120
 #define NCVLOOPS      5
+#define NRWLOOPS      10
 #define NTHREADS      32
 
 static volatile unsigned long testval1;
@@ -49,6 +50,7 @@ static volatile unsigned long testval3;
 static struct semaphore *testsem;
 static struct lock *testlock;
 static struct cv *testcv;
+static struct rwlock *testrw;
 static struct semaphore *donesem;
 
 static
@@ -73,6 +75,12 @@ inititems(void)
 			panic("synchtest: cv_create failed\n");
 		}
 	}
+	if (testrw==NULL) {
+		testrw = rwlock_create("testrw");
+		if (testrw == NULL) {
+			panic("synchtest: rwlock_create failed\n");
+		}
+	}
 	if (donesem==NULL) {
 		donesem = sem_create("donesem", 0);
 		if (donesem == NULL) {
@@ -357,3 +365,81 @@ cvtest2(int nargs, char **args)
 
 	return 0;
 }
+
+static
+void
+readrwtestthread(void *junk, unsigned long num)
+{
+	int i;
+	(void)junk;
+
+	rwlock_acquire_read(testrw);
+	kprintf("\nReadThread %lu: ", num);
+	for(i=0;i<NRWLOOPS;i++)
+	{
+		kprintf("%ld ",testval2);
+	}
+	rwlock_release_read(testrw);
+
+	V(donesem);
+}
+
+static
+void
+writerwtestthread(void *junk, unsigned long num)
+{
+	int i;
+	(void)junk;
+
+	rwlock_acquire_write(testrw);
+	kprintf("\nWriteThread %lu: ", num);
+	for(i=0;i<NRWLOOPS;i++)
+	{
+		kprintf("%ld ",++testval2);
+	}
+	rwlock_release_write(testrw);
+
+	V(donesem);
+}
+
+int
+rwtest(int nargs, char **args)
+{
+	int i, result;
+
+	(void)nargs;
+	(void)args;
+
+	inititems();
+	kprintf("Starting new RW test...\n");
+	kprintf("Threads should print out in order.\n");
+	testval1 = NTHREADS-1;
+	testval2=0;
+
+	for (i=0; i<NTHREADS*2; i++) {
+
+		result = thread_fork("readrwtest", readrwtestthread, NULL, i,
+				      NULL);
+
+		if (result) {
+			panic("readrwtest: thread_fork failed: %s\n",
+			      strerror(result));
+		}
+	}
+
+	for (i=0; i<NTHREADS; i++) {
+		result = thread_fork("writerwtest", writerwtestthread, NULL, i,
+				      NULL);
+		if (result) {
+			panic("writerwtest: thread_fork failed: %s\n",
+			      strerror(result));
+		}
+	}
+
+	for (i=0; i<NTHREADS+NTHREADS; i++) {
+		P(donesem);
+	}
+	kprintf("\n");
+	kprintf("RW test done\n");
+	return 0;	
+}
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..ebf8602 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -34,6 +34,7 @@
 
 #include <types.h>
 #include <lib.h>
+#include <spl.h>
 #include <spinlock.h>
 #include <wchan.h>
 #include <thread.h>
@@ -147,6 +148,24 @@ V(struct semaphore *sem)
 //
 // Lock.
 
+/*int lock_data_get(volatile int *d)
+{
+	return *d;
+}
+void lock_data_set(volatile int *d, int val)
+{
+	*d=val;
+}
+int lock_data_testandset(volatile int *d)
+{
+	int x,y;
+	x=*d;
+	y=1;
+	if(x==0)
+		*d=y;
+	return x;
+}*/
+
 struct lock *
 lock_create(const char *name)
 {
@@ -156,14 +175,19 @@ lock_create(const char *name)
         if (lock == NULL) {
                 return NULL;
         }
-
+        lock->lk_holder=NULL;
         lock->lk_name = kstrdup(name);
         if (lock->lk_name == NULL) {
                 kfree(lock);
                 return NULL;
         }
-        
-        // add stuff here as needed
+
+	lock->lk_wchan = wchan_create(name);
+	if (lock->lk_wchan == NULL) {
+		kfree(lock->lk_wchan);
+		return NULL;
+	}
+	spinlock_init(&lock->lk_slock);
         
         return lock;
 }
@@ -172,9 +196,9 @@ void
 lock_destroy(struct lock *lock)
 {
         KASSERT(lock != NULL);
-
+	wchan_destroy(lock->lk_wchan);
         // add stuff here as needed
-        
+	spinlock_cleanup(&lock->lk_slock);
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -182,26 +206,56 @@ lock_destroy(struct lock *lock)
 void
 lock_acquire(struct lock *lock)
 {
+	struct thread *mythread;
         // Write this
+	KASSERT(lock!=NULL);
+	splraise(IPL_NONE, IPL_HIGH);
 
-        (void)lock;  // suppress warning until code gets written
+	if(lock_do_i_hold(lock))
+		panic("Deadlock on lock %p\n", lock);
+
+	mythread = curthread;
+	spinlock_acquire(&lock->lk_slock);
+	while (lock->lk_holder!=NULL) {
+
+		wchan_lock(lock->lk_wchan);
+		spinlock_release(&lock->lk_slock);
+		wchan_sleep(lock->lk_wchan);
+		spinlock_acquire(&lock->lk_slock);
+	}
+	lock->lk_holder = mythread;
+	spinlock_release(&lock->lk_slock);
+	spllower(IPL_HIGH, IPL_NONE);
+       //(void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
+	splraise(IPL_NONE, IPL_HIGH);
+// this must work before curcpu initialization
+
+	spinlock_acquire(&lock->lk_slock);
+	if(lock_do_i_hold(lock))
+	{
+	lock->lk_holder = NULL;
+	wchan_wakeone(lock->lk_wchan);
+	}
+	spinlock_release(&lock->lk_slock);
+	spllower(IPL_HIGH, IPL_NONE);
+
         // Write this
 
-        (void)lock;  // suppress warning until code gets written
+//    (void)lock;  // suppress warning until code gets written
 }
 
-bool
-lock_do_i_hold(struct lock *lock)
+bool lock_do_i_hold(struct lock *lock)
 {
-        // Write this
-
-        (void)lock;  // suppress warning until code gets written
+	KASSERT(lock!=NULL);
+	/* Assume we can read lk_holder atomically enough for this to work */
+	return (lock->lk_holder == curthread);
 
+//(void)lock;
         return true; // dummy until code gets written
 }
 
@@ -225,7 +279,14 @@ cv_create(const char *name)
                 kfree(cv);
                 return NULL;
         }
-        
+
+	cv->cv_wchan = wchan_create(cv->cv_name);
+	if (cv->cv_wchan == NULL) {
+		kfree(cv->cv_name);
+		kfree(cv);
+		return NULL;
+	}
+         cv->cv_count = 1;
         // add stuff here as needed
         
         return cv;
@@ -235,9 +296,8 @@ void
 cv_destroy(struct cv *cv)
 {
         KASSERT(cv != NULL);
-
+	wchan_destroy(cv->cv_wchan);
         // add stuff here as needed
-        
         kfree(cv->cv_name);
         kfree(cv);
 }
@@ -246,7 +306,16 @@ void
 cv_wait(struct cv *cv, struct lock *lock)
 {
         // Write this
-        (void)cv;    // suppress warning until code gets written
+        KASSERT(cv != NULL);
+	//  cv_wait      - Release the supplied lock, go to sleep, and, after waking up again, re-acquire the lock.
+	KASSERT(lock_do_i_hold(lock));
+		wchan_lock(cv->cv_wchan);
+		lock_release(lock);
+	        wchan_sleep(cv->cv_wchan);
+		lock_acquire(lock);
+	        //cv->cv_count++;
+
+   //     (void)cv;    // suppress warning until code gets written
         (void)lock;  // suppress warning until code gets written
 }
 
@@ -254,14 +323,151 @@ void
 cv_signal(struct cv *cv, struct lock *lock)
 {
         // Write this
-	(void)cv;    // suppress warning until code gets written
+        KASSERT(cv != NULL);
+//    cv_signal    - Wake up one thread that's sleeping on this CV.
+//	KASSERT(lock_do_i_hold(lock));
+//        lock_acquire(lock);
+        //KASSERT(cv->cv_count>0);
+        wchan_wakeone(cv->cv_wchan);
+	//cv->cv_count--;
+//        lock_release(lock);
+
+
+//	(void)cv;    // suppress warning until code gets written
 	(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
+        KASSERT(cv != NULL);
+//	KASSERT(lock_do_i_hold(lock));
 	// Write this
-	(void)cv;    // suppress warning until code gets written
+//	lock_acquire(lock);
+        //KASSERT(cv->cv_count>0);
+	wchan_wakeall(cv->cv_wchan);
+	//cv->cv_count=0;
+//	lock_release(lock);
+
+//	(void)cv;    // suppress warning until code gets written
 	(void)lock;  // suppress warning until code gets written
 }
+
+struct rwlock * rwlock_create(const char *name)
+{
+      struct rwlock *rw;
+
+        rw = kmalloc(sizeof(struct rwlock));
+        if (rw == NULL) {
+                return NULL;
+        }
+
+        rw->rwlock_name = kstrdup(name);
+        if (rw->rwlock_name==NULL) {
+                kfree(rw);
+                return NULL;
+        }
+        rw->rw_lock= lock_create(name);
+
+	if (rw->turn==NULL) {
+		rw->turn = cv_create(name);
+		if (rw->turn == NULL) {
+			panic("synchtest: cv_create failed for rw\n");
+		}
+	}
+	rw->rw_sem = sem_create("RW Read Semaphore",5);
+	rw->reading = 0;
+	rw->current_turn=-1;
+	rw->writers = 0;
+	rw->writing = 0;
+
+        return rw;
+}
+void rwlock_destroy(struct rwlock *rw)
+{
+        KASSERT(rw != NULL);
+
+        // add stuff here as needed
+        kfree(rw->rwlock_name);
+        kfree(rw->rw_lock);
+        kfree(rw->turn);
+        kfree(rw);
+
+}
+
+void rwlock_acquire_read(struct rwlock *rw)
+{
+	kprintf("\nAc Read");
+
+		/*if(rw->reading>5)
+		{
+			kprintf("\n\ng=%d,%d",rw->reading,rw->writers);
+				while(rw->writers!=0){
+				kprintf("\n\ng5");
+				}
+		}*/
+		while(1)
+		{
+		lock_acquire(rw->rw_lock);
+		if(rw->writers>0)
+			cv_wait(rw->turn, rw->rw_lock);
+		while(rw->writing)
+			cv_wait(rw->turn, rw->rw_lock);
+		//P(rw->rw_sem->sem_);
+/*		while(rw->reading>10 && rw->current_turn==0)
+		{
+			cv_broadcast(rw->turn,rw->rw_lock);
+			cv_wait(rw->turn, rw->rw_lock);
+		}
+		*/
+		if(rw->rw_sem->sem_count!=0)
+		{
+			P(rw->rw_sem);
+			rw->reading++;
+			lock_release(rw->rw_lock);
+			break;
+		}
+		lock_release(rw->rw_lock);
+		}
+		//rw->current_turn=0;
+
+
+
+
+		// Read goes on here
+
+}
+
+void rwlock_release_read(struct rwlock *rw)
+{
+		lock_acquire(rw->rw_lock);
+		rw->reading--;
+		if(rw->writers==0)
+			V(rw->rw_sem);
+		cv_broadcast(rw->turn,rw->rw_lock);
+		lock_release(rw->rw_lock);
+}
+
+void rwlock_acquire_write(struct rwlock *rw)
+{
+	kprintf("\nAc write");
+		lock_acquire(rw->rw_lock);
+		rw->writers++;
+		while(rw->writing || rw->reading)
+			cv_wait(rw->turn, rw->rw_lock);
+		rw->writing++;
+		rw->current_turn=1;
+		lock_release(rw->rw_lock);
+
+		// Write goes on here
+}
+
+void rwlock_release_write(struct rwlock *rw)
+{
+		lock_acquire(rw->rw_lock);
+		rw->writing--;
+		rw->writers--;
+		V(rw->rw_sem);
+		cv_broadcast(rw->turn,rw->rw_lock);
+		lock_release(rw->rw_lock);
+}
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..f4e8917 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -33,6 +33,7 @@
 
 #include <types.h>
 #include <kern/errno.h>
+#include <kern/fcntl.h>
 #include <lib.h>
 #include <array.h>
 #include <cpu.h>
@@ -47,14 +48,14 @@
 #include <addrspace.h>
 #include <mainbus.h>
 #include <vnode.h>
+#include <vfs.h>
 
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
-
+#include <syscall.h>
 
 /* Magic number used as a guard value on kernel thread stacks. */
 #define THREAD_STACK_MAGIC 0xbaadf00d
-
 /* Wait channel. */
 struct wchan {
 	const char *wc_name;		/* name for this channel */
@@ -113,6 +114,8 @@ thread_checkstack(struct thread *thread)
  * Create a thread. This is used both to create a first thread
  * for each CPU and to create subsequent forked threads.
  */
+
+
 static
 struct thread *
 thread_create(const char *name)
@@ -125,6 +128,12 @@ thread_create(const char *name)
 	if (thread == NULL) {
 		return NULL;
 	}
+	thread->process_id=pid_allocate();
+	thread->exit_sem=sem_create(name,0);
+	thread->priority=2;
+	thread->fd_count=0;
+	*(thread->f_handles)= NULL;
+
 
 	thread->t_name = kstrdup(name);
 	if (thread->t_name == NULL) {
@@ -176,12 +185,13 @@ cpu_create(unsigned hardware_number)
 	if (c == NULL) {
 		panic("cpu_create: Out of memory\n");
 	}
-	
+	c->c_processcount=PID_MIN+1;
 	c->c_self = c;
 	c->c_hardware_number = hardware_number;
 
 	c->c_curthread = NULL;
 	threadlist_init(&c->c_zombies);
+	pcount=0;
 	c->c_hardclocks = 0;
 
 	c->c_isidle = false;
@@ -465,6 +475,45 @@ thread_make_runnable(struct thread *target, bool already_have_lock)
 	}
 }
 
+pid_t pid_allocate()
+{
+	(void)curcpu->c_processcount;
+	(void)curthread;
+	(void)curthread->t_stack;
+	if(!CURCPU_EXISTS())
+	{
+		return PID_MIN;
+	}
+	pid_t new_pid = pcount + PID_MIN;
+
+	/*if(new_pid==-1)
+	{
+		int cnt=PID_MIN,flag=1;
+		struct threadlistnode ptr=curcpu->c_runqueue.tl_head;
+		while(flag)
+		{
+			if(ptr.tln_self == curcpu->c_runqueue.tl_tail.tln_self)
+				flag=0;
+			if(ptr.tln_self->process_id==cnt)
+			{
+				cnt++;
+				ptr=*(ptr.tln_next);
+			}
+			else
+				break;
+		}
+		new_pid=cnt;
+	}*/
+
+	/*if(pcount==PID_MAX)
+		curcpu->c_processcount=-1;
+	else
+		curcpu->c_processcount++;
+*/
+	return new_pid;
+}
+
+
 /*
  * Create a new thread based on an existing one.
  *
@@ -489,6 +538,7 @@ thread_fork(const char *name,
 		return ENOMEM;
 	}
 
+
 	/* Allocate a stack */
 	newthread->t_stack = kmalloc(STACK_SIZE);
 	if (newthread->t_stack == NULL) {
@@ -503,6 +553,23 @@ thread_fork(const char *name,
 
 	/* Thread subsystem fields */
 	newthread->t_cpu = curthread->t_cpu;
+	newthread->fd_count=curthread->fd_count;
+	for(int i=0;i<=newthread->fd_count+2;i++)
+	{
+		if(curthread->f_handles[i]!=NULL)
+		{
+		curthread->f_handles[i]->file_counter+=1;
+		newthread->f_handles[i]=kmalloc(sizeof(*newthread->f_handles[i]));
+		newthread->f_handles[i]->file_counter=curthread->f_handles[i]->file_counter;
+		newthread->f_handles[i]->file_name=kstrdup(curthread->f_handles[i]->file_name);
+		newthread->f_handles[i]->file_offset=curthread->f_handles[i]->file_offset;
+		newthread->f_handles[i]->op_flags=curthread->f_handles[i]->op_flags;
+		newthread->f_handles[i]->file_ref=curthread->f_handles[i]->file_ref;
+		newthread->f_handles[i]->file_lock=curthread->f_handles[i]->file_lock;
+		}
+	}
+	//*(newthread->f_handles)=kmalloc(curthread->fd_count*sizeof(curthread->f_handles));
+	//*(newthread->f_handles)=*(curthread->f_handles);
 
 	/* VM fields */
 	/* do not clone address space -- let caller decide on that */
@@ -523,6 +590,14 @@ thread_fork(const char *name,
 	/* Set up the switchframe so entrypoint() gets called */
 	switchframe_init(newthread, entrypoint, data1, data2);
 
+	plist[pcount]=kmalloc(sizeof(struct process));
+	plist[pcount]->pid=newthread->process_id;
+	plist[pcount]->exitcode=-999;
+	plist[pcount]->esem=newthread->exit_sem;
+	plist[pcount]->ppid=curthread->process_id;
+	newthread->parent=curthread;
+	plist[pcount++]->tptr=newthread;
+
 	/* Lock the current cpu's run queue and make the new thread runnable */
 	thread_make_runnable(newthread, false);
 
diff --git a/kern/vm/addrspace.c b/kern/vm/addrspace.c
index 302fa7b..fa6e3b8 100644
--- a/kern/vm/addrspace.c
+++ b/kern/vm/addrspace.c
@@ -59,21 +59,10 @@ as_create(void)
 int
 as_copy(struct addrspace *old, struct addrspace **ret)
 {
-	struct addrspace *newas;
-
-	newas = as_create();
-	if (newas==NULL) {
-		return ENOMEM;
-	}
-
-	/*
-	 * Write this.
-	 */
-
 	(void)old;
-	
-	*ret = newas;
-	return 0;
+	(void)ret;
+		return 0;
+
 }
 
 void
@@ -159,4 +148,3 @@ as_define_stack(struct addrspace *as, vaddr_t *stackptr)
 	
 	return 0;
 }
-
diff --git a/kern/vm/copyinout.c b/kern/vm/copyinout.c
index 39843e7..2c4c7a8 100644
--- a/kern/vm/copyinout.c
+++ b/kern/vm/copyinout.c
@@ -142,6 +142,36 @@ copycheck(const_userptr_t userptr, size_t len, size_t *stoplen)
 	return 0;
 }
 
+
+int
+copycheck2(const_userptr_t userptr, size_t len, size_t *stoplen)
+{
+	vaddr_t bot, top;
+
+	*stoplen = len;
+
+	bot = (vaddr_t) userptr;
+	top = bot+len-1;
+
+	if (top < bot) {
+		/* addresses wrapped around */
+		return EFAULT;
+	}
+
+	if (bot >= USERSPACETOP) {
+		/* region is within the kernel */
+		return EFAULT;
+	}
+
+	if (top >= USERSPACETOP) {
+		/* region overlaps the kernel. adjust the max length. */
+		*stoplen = USERSPACETOP - bot;
+	}
+
+	return 0;
+}
+
+
 /*
  * copyin
  *
@@ -235,7 +265,37 @@ int
 copystr(char *dest, const char *src, size_t maxlen, size_t stoplen,
 	size_t *gotlen)
 {
+
+	size_t i;
+
+	for (i=0; i<maxlen && i<stoplen; i++) {
+		dest[i] = src[i];
+		if (src[i] == 0) {
+			if (gotlen != NULL) {
+				*gotlen = i+1;
+			}
+			return 0;
+		}
+	}
+
+	if (stoplen < maxlen) {
+		/* ran into user-kernel boundary */
+		return EFAULT;
+	}
+
+	/* otherwise just ran out of space */
+	return ENAMETOOLONG;
+}
+
+int
+copystr2(char *dest, const char *src, size_t maxlen, size_t stoplen,
+	size_t *gotlen)
+{
+
 	size_t i;
+	kprintf("ENTREY=%d",strlen(dest));
+	if(strlen(dest)<1)
+			return EINVAL;
 
 	for (i=0; i<maxlen && i<stoplen; i++) {
 		dest[i] = src[i];
@@ -246,10 +306,13 @@ copystr(char *dest, const char *src, size_t maxlen, size_t stoplen,
 			return 0;
 		}
 	}
+
 	if (stoplen < maxlen) {
 		/* ran into user-kernel boundary */
+
 		return EFAULT;
 	}
+
 	/* otherwise just ran out of space */
 	return ENAMETOOLONG;
 }
@@ -272,7 +335,6 @@ copyinstr(const_userptr_t usersrc, char *dest, size_t len, size_t *actual)
 	if (result) {
 		return result;
 	}
-
 	curthread->t_machdep.tm_badfaultfunc = copyfail;
 
 	result = setjmp(curthread->t_machdep.tm_copyjmp);
@@ -281,6 +343,13 @@ copyinstr(const_userptr_t usersrc, char *dest, size_t len, size_t *actual)
 		return EFAULT;
 	}
 
+	const char* src= (const char *) usersrc;
+	if(src[0]=='\0')
+	{
+		curthread->t_machdep.tm_badfaultfunc = NULL;
+		return EINVAL;
+	}
+
 	result = copystr(dest, (const char *)usersrc, len, stoplen, actual);
 
 	curthread->t_machdep.tm_badfaultfunc = NULL;
diff --git a/kern/vm/kmalloc.c b/kern/vm/kmalloc.c
index 09b764b..4f0a575 100644
--- a/kern/vm/kmalloc.c
+++ b/kern/vm/kmalloc.c
@@ -30,6 +30,7 @@
 #include <types.h>
 #include <lib.h>
 #include <spinlock.h>
+#include <addrspace.h>
 #include <vm.h>
 
 /*
diff --git a/kern/vm/vm.c b/kern/vm/vm.c
new file mode 100644
index 0000000..36a471a
--- /dev/null
+++ b/kern/vm/vm.c
@@ -0,0 +1,281 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <spl.h>
+#include <thread.h>
+#include <synch.h>
+#include <current.h>
+#include <mips/tlb.h>
+#include <addrspace.h>
+#include <vm.h>
+
+
+#define DUMBVM_STACKPAGES    12
+
+static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+static struct lock *coremap_lock;
+static struct coremap_page *core_map;
+static int vm_bootstrapped=0, free_index, last_index;
+static paddr_t freeaddr;
+static paddr_t ROUNDDOWN(paddr_t size)
+{
+	if(size%PAGE_SIZE!=0)
+	{
+	size = ((size + PAGE_SIZE - 1) & ~(size_t)(PAGE_SIZE-1));
+	size-=PAGE_SIZE;
+	}
+	return size;
+}
+static int getpageindex(paddr_t addr)
+{
+	return ROUNDDOWN(addr)/PAGE_SIZE;
+}
+
+void
+vm_bootstrap(void)
+{
+	coremap_lock = lock_create("core_map");
+	paddr_t first_addr, lastaddr;
+	ram_getsize(&first_addr, &lastaddr);
+	int total_page_num = ROUNDDOWN(lastaddr) / PAGE_SIZE;
+	/* pages should be a kernel virtual address !!  */
+	core_map = (struct coremap_page*)PADDR_TO_KVADDR(first_addr);
+	freeaddr = first_addr + total_page_num * sizeof(struct coremap_page);
+	//kprintf("\n%d,%d,%d,%d\n",ROUNDDOWN(lastaddr-freeaddr, PAGE_SIZE) / PAGE_SIZE,firstaddr,lastaddr,total_page_num);
+
+	// Set page as fixed for paddr 0 to freeaddr
+	free_index=getpageindex(freeaddr);
+	last_index=getpageindex(lastaddr);
+	for(int i=0;i<last_index;i++)
+	{
+		if(i<free_index)
+			core_map[i].pstate=FIXED;
+		else
+			core_map[i].pstate=FREE;
+	}
+	vm_bootstrapped=1;
+	//kprintf("%d,%d,%d",getpageindex(0),getpageindex(freeaddr),getpageindex(lastaddr));
+
+
+}
+
+/* Allocate/free some kernel-space virtual pages */
+vaddr_t alloc_page(void)
+{
+	paddr_t pa;
+	lock_acquire(coremap_lock);
+	int found=-1;
+	for(int i=free_index;i<last_index;i++)
+	{
+		if(core_map[i].pstate==FREE)
+		{
+			core_map[i].pstate=DIRTY;
+			core_map[i].npages=1;
+			found=i;
+			break;
+		}
+	}
+	lock_release(coremap_lock);
+
+	if (found==-1) {
+		return 0;
+	}
+	pa= freeaddr + (found * PAGE_SIZE);
+
+	return PADDR_TO_KVADDR(pa);
+}
+
+static
+paddr_t
+getppages(unsigned long npages)
+{
+	paddr_t addr;
+	spinlock_acquire(&stealmem_lock);
+	//lock_acquire(coremap_lock);
+
+	addr = ram_stealmem(npages);
+	spinlock_release(&stealmem_lock);
+	//lock_release(coremap_lock);
+	return addr;
+}
+
+/* Allocate/free some kernel-space virtual pages */
+vaddr_t
+alloc_kpages(int npages)
+{
+	paddr_t pa;
+	if(vm_bootstrapped==0)
+		pa = getppages(npages);
+	else
+	{
+		lock_acquire(coremap_lock);
+		int found=-1,start=-1;
+		for(int i=free_index;i<last_index;i++)
+		{
+			if(core_map[i].pstate==FREE)
+			{
+				if(start==-1)
+					start=i;
+				if(i-start==npages-1)
+				{
+					core_map[start].pstate=FIXED;
+					core_map[start].npages=npages;
+					found=i;
+					break;
+				}
+			}
+			else if(start!=-1)
+			{
+				start=-1;
+			}
+		}
+		lock_release(coremap_lock);
+
+		if (found==-1) {
+			return 0;
+		}
+		pa= (start * PAGE_SIZE);
+	}
+	if (pa==0) {
+		return 0;
+	}
+	return PADDR_TO_KVADDR(pa);
+}
+
+void
+free_page(vaddr_t addr)
+{
+	for(int i=free_index;i<last_index;i++)
+	{
+		if((vaddr_t)(i*PAGE_SIZE)==addr)
+		{
+			//for(int j=i;j<i+core_map[i].npages;j++)
+			{
+				core_map[i].pstate=FREE;
+			}
+			break;
+		}
+	}
+}
+
+void
+free_kpages(vaddr_t addr)
+{
+	for(int i=free_index;i<last_index;i++)
+	{
+		if((freeaddr+(i*PAGE_SIZE))==addr)
+		{
+			for(int j=i;j<i+core_map[i].npages;j++)
+			{
+				core_map[j].pstate=FREE;
+			}
+			break;
+		}
+	}
+}
+
+void
+vm_tlbshootdown_all(void)
+{
+	panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+void
+vm_tlbshootdown(const struct tlbshootdown *ts)
+{
+	(void)ts;
+	panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+int
+vm_fault(int faulttype, vaddr_t faultaddress)
+{
+	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+	paddr_t paddr;
+	int i;
+	uint32_t ehi, elo;
+	struct addrspace *as;
+	int spl;
+
+	faultaddress &= PAGE_FRAME;
+
+	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+
+	switch (faulttype) {
+	    case VM_FAULT_READONLY:
+		/* We always create pages read-write, so we can't get this */
+		panic("dumbvm: got VM_FAULT_READONLY\n");
+	    case VM_FAULT_READ:
+	    case VM_FAULT_WRITE:
+		break;
+	    default:
+		return EINVAL;
+	}
+
+	as = curthread->t_addrspace;
+	if (as == NULL) {
+		/*
+		 * No address space set up. This is probably a kernel
+		 * fault early in boot. Return EFAULT so as to panic
+		 * instead of getting into an infinite faulting loop.
+		 */
+		return EFAULT;
+	}
+
+	/* Assert that the address space has been set up properly. */
+	KASSERT(as->as_vbase1 != 0);
+	KASSERT(as->as_pbase1 != 0);
+	KASSERT(as->as_npages1 != 0);
+	KASSERT(as->as_vbase2 != 0);
+	KASSERT(as->as_pbase2 != 0);
+	KASSERT(as->as_npages2 != 0);
+	KASSERT(as->as_stackpbase != 0);
+	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+
+	vbase1 = as->as_vbase1;
+	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+	vbase2 = as->as_vbase2;
+	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+	stacktop = USERSTACK;
+
+	if (faultaddress >= vbase1 && faultaddress < vtop1) {
+		paddr = (faultaddress - vbase1) + as->as_pbase1;
+	}
+	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+		paddr = (faultaddress - vbase2) + as->as_pbase2;
+	}
+	else if (faultaddress >= stackbase && faultaddress < stacktop) {
+		paddr = (faultaddress - stackbase) + as->as_stackpbase;
+	}
+	else {
+		return EFAULT;
+	}
+
+	/* make sure it's page-aligned */
+	KASSERT((paddr & PAGE_FRAME) == paddr);
+
+	/* Disable interrupts on this CPU while frobbing the TLB. */
+	spl = splhigh();
+
+	for (i=0; i<NUM_TLB; i++) {
+		tlb_read(&ehi, &elo, i);
+		if (elo & TLBLO_VALID) {
+			continue;
+		}
+		ehi = faultaddress;
+		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+		tlb_write(ehi, elo, i);
+		splx(spl);
+		return 0;
+	}
+
+	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+	splx(spl);
+	return EFAULT;
+}
diff --git a/user/sbin/reboot/reboot.c b/user/sbin/reboot/reboot.c
index 37ff4f6..ace9830 100644
--- a/user/sbin/reboot/reboot.c
+++ b/user/sbin/reboot/reboot.c
@@ -28,7 +28,6 @@
  */
 
 #include <unistd.h>
-
 /*
  * reboot - shut down system and reboot it.
  * Usage: reboot
diff --git a/user/testbin/Makefile b/user/testbin/Makefile
index e7f2259..edd3d08 100644
--- a/user/testbin/Makefile
+++ b/user/testbin/Makefile
@@ -9,7 +9,7 @@ SUBDIRS=add argtest badcall bigfile conman crash ctest dirconc dirseek \
 	dirtest f_test farm faulter fileonlytest filetest forkbomb forktest guzzle \
 	hash hog huge kitchen malloctest matmult palin parallelvm psort \
 	randcall rmdirtest rmtest sink sort sty tail tictac triplehuge \
-	triplemat triplesort
+	triplemat triplesort p_syscalls
 
 # But not:
 #    userthreads    (no support in kernel API in base system)
diff --git a/user/testbin/badcall/bad_waitpid.c b/user/testbin/badcall/bad_waitpid.c
index 809c68c..ff9e70e 100644
--- a/user/testbin/badcall/bad_waitpid.c
+++ b/user/testbin/badcall/bad_waitpid.c
@@ -36,7 +36,7 @@
 #include <unistd.h>
 #include <errno.h>
 #include <err.h>
-
+#include <stdio.h>
 #include "config.h"
 #include "test.h"
 
@@ -166,7 +166,7 @@ wait_siblings_child(void)
 		     mypid, TESTFILE);
 		return;
 	}
-
+	// printf("\ngoing to busy wait\n");
 	/*
 	 * Busy-wait until the parent writes the pids into the file.
 	 * This sucks, but there's not a whole lot else we can do.
@@ -185,7 +185,7 @@ wait_siblings_child(void)
 			return;
 		}
 	} while (rv < (int)sizeof(pids));
-
+	// printf("\nb over\n");
 	if (mypid==pids[0]) {
 		otherpid = pids[1];
 	}
@@ -215,19 +215,22 @@ wait_siblings(void)
 	if (fd<0) {
 		return;
 	}
-
+	// printf("\ntestfile opened\n");
 	pids[0] = fork();
 	if (pids[0]<0) {
 		warn("UH-OH: can't fork");
 		return;
 	}
+	// printf("\nforked0 opened\n");
 	if (pids[0]==0) {
 		close(fd);
+		// printf("\nchild closed fd\n");
 		wait_siblings_child();
 		_exit(0);
 	}
 
 	pids[1] = fork();
+	// printf("\nforked1 opened\n");
 	if (pids[1]<0) {
 		warn("UH-OH: can't fork");
 		/* abandon the other child process :( */
@@ -235,6 +238,7 @@ wait_siblings(void)
 	}
 	if (pids[1]==0) {
 		close(fd);
+		// printf("\nchild closed fd\n");
 		wait_siblings_child();
 		_exit(0);
 	}
@@ -250,12 +254,14 @@ wait_siblings(void)
 		/* abandon child procs :( */
 		return;
 	}
-
+	// printf("\nwrite done on fd by parent and going to waitpid on child\n");
 	rv = waitpid(pids[0], &x, 0);
+	// printf("\nwaitpid0 over\n");
 	if (rv<0) {
 		warn("UH-OH: error waiting for child 0 (pid %d)", pids[0]);
 	}
 	rv = waitpid(pids[1], &x, 0);
+	// printf("\nwaitpid1 over\n");
 	if (rv<0) {
 		warn("UH-OH: error waiting for child 1 (pid %d)", pids[1]);
 	}
diff --git a/user/testbin/p_syscalls/Makefile b/user/testbin/p_syscalls/Makefile
new file mode 100644
index 0000000..8d737a2
--- /dev/null
+++ b/user/testbin/p_syscalls/Makefile
@@ -0,0 +1,11 @@
+# Makefile for add
+
+TOP=../../..
+.include "$(TOP)/mk/os161.config.mk"
+
+PROG=p_syscalls
+SRCS=p_syscalls.c
+BINDIR=/testbin
+
+.include "$(TOP)/mk/os161.prog.mk"
+
diff --git a/user/testbin/p_syscalls/p_syscalls.c b/user/testbin/p_syscalls/p_syscalls.c
new file mode 100644
index 0000000..4fa7740
--- /dev/null
+++ b/user/testbin/p_syscalls/p_syscalls.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Simple program to add two numbers (given in as arguments). Used to
+ * test argument passing to child processes.
+ *
+ * Intended for the basic system calls assignment; this should work
+ * once execv() argument handling is implemented.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+int
+main()
+{
+
+	//(void *)argc;
+	//(void *)argv;
+	printf("Answer: %d\n", getpid());
+	int *null = NULL;
+	volatile int x;
+	x = *null;
+
+	return 0;
+}
